
/********************************************************************************************
* 实验21:   RS485通迅实验
* CPU型号： PIC16F877A 
* 晶振：    4MHz 
* 说明:     串口调试软件波特率设为9600并设置为十六进制发送  
            通过串口调试助手向单片机发送一个字节的数据
            单片机会返回一个字节的数据给计算机并在数码管
            上显示接接收到的数据

            要完成RS485通迅实验你需要准备一个USB转485模块，
            或者准备两块具有485功能的开发板
            
* 作    者：MCU2000
* 日    期：2012年10月19日
本例程在<<BK300 PIC实验板>>上调试通过
*********************************************************************************************/

#include <pic.h>	      //包含PIC头文件 软件自带的头文件可以用< >
#include "BoardConfig.h"  //包含开发板硬件初始化头文件 自已写的头文件用" " 否测PICC编译会出错
__CONFIG(0x3F32);         //芯片配置字

#define  RE_DE    RE2
#define  LED_DATA PORTD
#define  LED_CTRL PORTA


//========================================================================

void US_delay( uint i); 
void mcu_init(void);
void interrupt usart(void);

uchar LED_DIS[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,
                  0x80,0x90,0X88,0X83,0XC6,0XA1,0X86,0X8E,0XFF};

uchar Dat_buff;                   //储存485接收到的数据
uchar couter;

void main()
{
     Board_init();              //调用开发板硬件初始化函数
     mcu_init();                  //USART初始化
     while(1);                    //等待接收中断  
}

void mcu_init(void)
{
     OPTION=0x06;                //TMR0----128分频
     INTCON=0XA0;                //开总中断及TMR0计数溢出断
     TMR0=0xC8;                  //定时器初值

     TRISC=0X80;                 //设置RC口方向
     SPBRG=0X19;                 //设置波特率为9600BPS
     TXSTA=0X24;                 //使能串口发送，选择高速波特率
     RCSTA=0X90;                 //使能串口工作，连续接收
     RCIE=0X1;                   //使能接收中断
     GIE=0X1;                    //开放全局中断
     PEIE=0X1;                   //使能外部中断
     RE_DE=0;                    //RE_DE低电平，平时为接收状态
}

//PIC只有一个中断入口所以进入中断后需要判断是哪部分产生了中断
void interrupt usart(void)
{
    //判断是否USART中断
    if(RCIE&&RCIF)               //判断是否为串口接收中断
    {
         RE_DE=1;                //设置为发送模式

         US_delay(100);
         Dat_buff=RCREG;         //暂存485接收到的数据
         TXREG=Dat_buff;         //把接收到的数据发送回去
         US_delay(200);
         RE_DE=0;                //恢复为接收模式
         US_delay(100);
    } 
    //判断是否定时器溢出中断
    else if(T0IF)
    {
         T0IF=0;
         TMR0=0xc8;
         if(++couter==2)
         {                      //十位
                couter=0;
                //****************数码管段码****************************************************
                RC3=1;
                PORTD=LED_DIS[(Dat_buff>>4) & 0X0F];
                RC3=0;
                //******************************************************************************

                //****************数码管位码****************************************************
                RC4=1;                      //U3锁存端设为高电平输出端电平随输入端而变化
                PORTD=0X20;                 //送数码管位码
                RC4=0;                      //U3锁存端设为低电平输出端不变
                //******************************************************************************     
         }
         
         else
         {                    //个位
         
              //****************数码管段码****************************************************
                RC3=1;
                PORTD=LED_DIS[Dat_buff&0x0f];
                RC3=0;
                //******************************************************************************

                //****************数码管位码****************************************************
                RC4=1;                      //U3锁存端设为高电平输出端电平随输入端而变化
                PORTD=0X10;                 //送数码管位码
                RC4=0;                      //U3锁存端设为低电平输出端不变
                //******************************************************************************
         }       
    }  
}

/***************毫秒级延时*******************/
void US_delay( uint i) 
{
     uchar j;
     while(i--)
     {
         j=3;
         while(j--);
     }
}
